--- Setup Hooks Module for Claude Code Attention Notifications
--- Provides utilities to create hook scripts and install Claude Code configuration
local M = {}

local config = require "ai-tools.task-workflow.config"

--- Generate the Claude Code hooks configuration
---@return table hooks_config The hooks configuration table
function M.generate_hooks_config()
  local cfg = config.notifications.claude_attention
  if not cfg.enabled then
    return {}
  end

  local scripts_dir = vim.fn.stdpath "config" .. "/scripts"
  local attention_script = scripts_dir .. "/claude-attention.sh"
  local clear_script = scripts_dir .. "/claude-attention-clear.sh"

  local hooks = {
    UserPromptSubmit = {
      {
        hooks = {
          { type = "command", command = clear_script },
        },
      },
    },
  }

  -- Add notification hooks based on enabled events
  local notification_hooks = {}

  if cfg.events.permission_prompt then
    table.insert(notification_hooks, {
      matcher = "permission_prompt",
      hooks = {
        { type = "command", command = attention_script },
      },
    })
  end

  if cfg.events.idle_prompt then
    table.insert(notification_hooks, {
      matcher = "idle_prompt",
      hooks = {
        { type = "command", command = attention_script },
      },
    })
  end

  if #notification_hooks > 0 then
    hooks.Notification = notification_hooks
  end

  if cfg.events.stop then
    hooks.Stop = {
      {
        hooks = {
          { type = "command", command = attention_script },
        },
      },
    }
  end

  return { hooks = hooks }
end

--- Write hooks configuration to Claude Code settings
---@param merge boolean|nil Whether to merge with existing settings (default: true)
---@return table result { success: boolean, error: string|nil }
function M.install_hooks(merge)
  merge = merge ~= false

  local claude_settings_path = vim.fn.expand "~/.claude/settings.json"
  local hooks_config = M.generate_hooks_config()

  if merge then
    -- Read existing settings
    local existing = {}
    local f = io.open(claude_settings_path, "r")
    if f then
      local content = f:read "*all"
      f:close()
      local ok, decoded = pcall(vim.json.decode, content)
      if ok and decoded then
        existing = decoded
      end
    end

    -- Merge hooks
    existing.hooks = existing.hooks or {}
    for event, event_hooks in pairs(hooks_config.hooks) do
      existing.hooks[event] = event_hooks
    end

    hooks_config = existing
  end

  -- Ensure directory exists
  vim.fn.mkdir(vim.fn.expand "~/.claude", "p")

  -- Write settings
  local f = io.open(claude_settings_path, "w")
  if not f then
    return { success = false, error = "Failed to open settings file for writing" }
  end

  local ok, encoded = pcall(vim.json.encode, hooks_config)
  if not ok then
    f:close()
    return { success = false, error = "Failed to encode JSON: " .. tostring(encoded) }
  end

  f:write(encoded)
  f:close()

  return { success = true }
end

--- Generate the attention script content
---@return string script_content The bash script content
function M.generate_attention_script()
  local cfg = config.notifications.claude_attention

  local system_notification_block = ""
  if cfg.system_notification.enabled then
    -- Using [=[ ]=] to avoid confusion with bash [[ ]]
    system_notification_block = [=[
# System notification
if command -v notify-send &> /dev/null; then
  notify-send "Claude Code" "Needs your attention" -i terminal
elif command -v osascript &> /dev/null; then
  osascript -e 'display notification "Needs your attention" with title "Claude Code"'
fi
]=]
  end

  -- Using [=[ ]=] to avoid confusion with bash [[ ]]
  -- This script modifies window-status-current-format to work with themed tmux configs
  return string.format(
    [=[#!/bin/bash
# Claude Code Attention Hook Script
# Auto-generated by task-workflow setup
# Uses format-based approach to work with themed tmux configs

set -e

CURRENT_WINDOW=$(tmux display-message -p '#I')

# Attention styling config
ATTENTION_ICON="%s"
ATTENTION_BG="%s"
ATTENTION_FG="%s"

# Theme colors to replace (Dracula theme defaults)
THEME_BG="%s"
THEME_FG="%s"
THEME_ACCENT="%s"

# Get the global window-status-current-format
ORIG_FORMAT=$(tmux show-options -gv window-status-current-format)

# Replace theme colors with attention colors and add icon
NEW_FORMAT=$(echo "$ORIG_FORMAT" | sed \
  -e "s/$THEME_BG/$ATTENTION_BG/g" \
  -e "s/$THEME_FG/$ATTENTION_FG/g" \
  -e "s/$THEME_ACCENT/$ATTENTION_FG/g" \
  -e "s/#I/#I $ATTENTION_ICON/")

# Apply the modified format to this window
tmux set-window-option -t "$CURRENT_WINDOW" window-status-current-format "$NEW_FORMAT"

%sexit 0
]=],
    cfg.tmux_style.icon,
    cfg.tmux_style.bg_color,
    cfg.tmux_style.fg_color,
    cfg.tmux_style.theme_bg,
    cfg.tmux_style.theme_fg,
    cfg.tmux_style.theme_accent,
    system_notification_block
  )
end

--- Generate the clear script content
---@return string script_content The bash script content
function M.generate_clear_script()
  -- Using [=[ ]=] to avoid confusion with bash [[ ]]
  -- Simply unset the window-specific format to revert to global default
  return [=[#!/bin/bash
# Claude Code Attention Clear Script
# Auto-generated by task-workflow setup

set -e

CURRENT_WINDOW=$(tmux display-message -p '#I')

# Reset window-status-current-format to default (inherit from global)
tmux set-window-option -t "$CURRENT_WINDOW" -u window-status-current-format

exit 0
]=]
end

--- Create the hook scripts in the scripts directory
---@return table result { success: boolean, error: string|nil }
function M.create_scripts()
  local scripts_dir = vim.fn.stdpath "config" .. "/scripts"
  vim.fn.mkdir(scripts_dir, "p")

  -- Write attention script
  local attention_path = scripts_dir .. "/claude-attention.sh"
  local f = io.open(attention_path, "w")
  if not f then
    return { success = false, error = "Failed to create attention script" }
  end
  f:write(M.generate_attention_script())
  f:close()
  vim.fn.system("chmod +x " .. vim.fn.shellescape(attention_path))

  -- Write clear script
  local clear_path = scripts_dir .. "/claude-attention-clear.sh"
  f = io.open(clear_path, "w")
  if not f then
    return { success = false, error = "Failed to create clear script" }
  end
  f:write(M.generate_clear_script())
  f:close()
  vim.fn.system("chmod +x " .. vim.fn.shellescape(clear_path))

  return { success = true }
end

--- Full setup: create scripts and install hooks
---@return table result { success: boolean, error: string|nil }
function M.setup()
  local result = M.create_scripts()
  if not result.success then
    return result
  end

  result = M.install_hooks(true)
  if not result.success then
    return result
  end

  return { success = true }
end

return M
